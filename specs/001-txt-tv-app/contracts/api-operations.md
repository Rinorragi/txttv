# API Contracts: TXT TV Application

**Feature**: 001-txt-tv-app  
**Date**: 2026-01-31  
**Phase**: 1 - Design

## Overview

This document defines the API operations exposed through Azure API Management. All operations are implemented primarily through APIM policy transformations, with minimal backend involvement.

## Base Configuration

**Base URL**: `https://{appgw-public-ip}` (Application Gateway public endpoint)  
**APIM Backend**: `https://{apim-name}.azure-api.net`  
**Function Backend**: `https://{function-app-name}.azurewebsites.net`

**Global Headers**:
- `X-Correlation-ID`: Generated by APIM for request tracing
- `Content-Type`: `text/html; charset=utf-8` (for page responses)

**Rate Limiting**: 100 requests per minute per IP address (enforced by WAF)

## API Operations

### 1. Get Page

Retrieve and render a specific TXT TV page.

**Endpoint**: `GET /page/{pageNumber}`

**Parameters**:
| Name | Type | Required | Location | Description |
|------|------|----------|----------|-------------|
| pageNumber | integer | Yes | path | Page number to retrieve (100-999) |

**Request Example**:
```http
GET /page/100 HTTP/1.1
Host: txttv.example.com
Accept: text/html
```

**Response** (Success - 200 OK):
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
X-Correlation-ID: 12345678-1234-1234-1234-123456789012
Cache-Control: public, max-age=300

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TXT TV - Page 100</title>
    <style>
        /* Teletext CSS inline */
    </style>
</head>
<body>
    <div id="content">
        <h1>Page 100</h1>
        <pre>BREAKING NEWS - Technology Update...</pre>
        <nav>
            <button hx-get="/page/99" hx-target="#content">← Previous</button>
            <input type="number" id="pageNum" value="100" />
            <button hx-get="/page/{pageNum}" hx-target="#content">Go</button>
            <button hx-get="/page/101" hx-target="#content">Next →</button>
        </nav>
    </div>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
</body>
</html>
```

**Response** (Page Not Found - 200 OK with error content):
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
X-Correlation-ID: 12345678-1234-1234-1234-123456789012

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TXT TV - Page Not Found</title>
</head>
<body>
    <div id="content">
        <h1>Page Not Found</h1>
        <pre>Page 500 does not exist.

Available pages: 100-120

Click below to return to the home page.</pre>
        <nav>
            <button hx-get="/page/100" hx-target="#content">Go to Page 100</button>
        </nav>
    </div>
</body>
</html>
```

**Response** (Invalid Input - 400 Bad Request):
```http
HTTP/1.1 400 Bad Request
Content-Type: application/json
X-Correlation-ID: 12345678-1234-1234-1234-123456789012

{
  "error": "Invalid page number",
  "message": "Page number must be an integer between 100 and 999",
  "requestedValue": "abc"
}
```

**APIM Policy Implementation**:
```xml
<policies>
    <inbound>
        <base />
        <set-variable name="pageNumber" value="@(context.Request.MatchedParameters["pageNumber"])" />
        <set-variable name="correlationId" value="@(Guid.NewGuid().ToString())" />
        <set-header name="X-Correlation-ID" exists-action="override">
            <value>@((string)context.Variables["correlationId"])</value>
        </set-header>
        
        <!-- Validate page number -->
        <choose>
            <when condition="@(!int.TryParse((string)context.Variables["pageNumber"], out int page) || page < 100 || page > 999)">
                <return-response>
                    <set-status code="400" reason="Bad Request" />
                    <set-header name="Content-Type" exists-action="override">
                        <value>application/json</value>
                    </set-header>
                    <set-body>@{
                        return new JObject(
                            new JProperty("error", "Invalid page number"),
                            new JProperty("message", "Page number must be an integer between 100 and 999"),
                            new JProperty("requestedValue", context.Variables["pageNumber"])
                        ).ToString();
                    }</set-body>
                </return-response>
            </when>
        </choose>
        
        <!-- Route to appropriate page fragment -->
        <choose>
            <when condition="@(context.Variables["pageNumber"] == "100")">
                <include-fragment fragment-id="page-100" />
            </when>
            <when condition="@(context.Variables["pageNumber"] == "101")">
                <include-fragment fragment-id="page-101" />
            </when>
            <when condition="@(context.Variables["pageNumber"] == "102")">
                <include-fragment fragment-id="page-102" />
            </when>
            <!-- Additional page conditions... -->
            <otherwise>
                <include-fragment fragment-id="error-page" />
            </otherwise>
        </choose>
        
        <return-response>
            <set-status code="200" reason="OK" />
            <set-header name="Content-Type" exists-action="override">
                <value>text/html; charset=utf-8</value>
            </set-header>
            <set-header name="Cache-Control" exists-action="override">
                <value>public, max-age=300</value>
            </set-header>
        </return-response>
    </inbound>
    <backend>
        <!-- No backend call - response generated by policy -->
    </backend>
    <outbound>
        <base />
    </outbound>
    <on-error>
        <base />
    </on-error>
</policies>
```

---

### 2. Get Home Page

Redirect to default page (100).

**Endpoint**: `GET /`

**Parameters**: None

**Request Example**:
```http
GET / HTTP/1.1
Host: txttv.example.com
Accept: text/html
```

**Response** (Redirect - 302 Found):
```http
HTTP/1.1 302 Found
Location: /page/100
X-Correlation-ID: 12345678-1234-1234-1234-123456789012
```

**Alternative Response** (Direct Render - 200 OK):
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8

<!-- Same HTML as GET /page/100 -->
```

**APIM Policy Implementation** (Redirect approach):
```xml
<policies>
    <inbound>
        <base />
        <return-response>
            <set-status code="302" reason="Found" />
            <set-header name="Location" exists-action="override">
                <value>/page/100</value>
            </set-header>
        </return-response>
    </inbound>
</policies>
```

---

### 3. Backend Connectivity Test

Call the F# Azure Function backend through the complete security stack.

**Endpoint**: `GET /backend-test`

**Parameters**: None

**Request Example**:
```http
GET /backend-test HTTP/1.1
Host: txttv.example.com
Accept: text/plain
```

**Response** (Success - 200 OK):
```http
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
X-Correlation-ID: 12345678-1234-1234-1234-123456789012
X-Backend-Called: true

you found through the maze
```

**Response** (Backend Unavailable - 503 Service Unavailable):
```http
HTTP/1.1 503 Service Unavailable
Content-Type: application/json
X-Correlation-ID: 12345678-1234-1234-1234-123456789012

{
  "error": "Backend unavailable",
  "message": "The backend function is not responding"
}
```

**APIM Policy Implementation**:
```xml
<policies>
    <inbound>
        <base />
        <set-variable name="correlationId" value="@(Guid.NewGuid().ToString())" />
        <set-header name="X-Correlation-ID" exists-action="override">
            <value>@((string)context.Variables["correlationId"])</value>
        </set-header>
        <set-backend-service base-url="https://{function-app-name}.azurewebsites.net" />
    </inbound>
    <backend>
        <forward-request timeout="10" />
    </backend>
    <outbound>
        <base />
        <set-header name="X-Backend-Called" exists-action="override">
            <value>true</value>
        </set-header>
    </outbound>
    <on-error>
        <return-response>
            <set-status code="503" reason="Service Unavailable" />
            <set-header name="Content-Type" exists-action="override">
                <value>application/json</value>
            </set-header>
            <set-body>@{
                return new JObject(
                    new JProperty("error", "Backend unavailable"),
                    new JProperty("message", "The backend function is not responding")
                ).ToString();
            }</set-body>
        </return-response>
    </on-error>
</policies>
```

---

## APIM Operation Definitions

These correspond to Bicep resources for APIM operations.

### Operation: GetPage

```json
{
  "name": "GetPage",
  "displayName": "Get TXT TV Page",
  "method": "GET",
  "urlTemplate": "/page/{pageNumber}",
  "templateParameters": [
    {
      "name": "pageNumber",
      "description": "Page number to retrieve (100-999)",
      "type": "integer",
      "required": true
    }
  ],
  "description": "Retrieve and render a specific TXT TV page using APIM policy fragments",
  "request": {
    "description": "Request for a specific page",
    "headers": [],
    "queryParameters": []
  },
  "responses": [
    {
      "statusCode": 200,
      "description": "Page content rendered successfully",
      "representations": [
        {
          "contentType": "text/html"
        }
      ]
    },
    {
      "statusCode": 400,
      "description": "Invalid page number",
      "representations": [
        {
          "contentType": "application/json"
        }
      ]
    }
  ]
}
```

### Operation: GetHome

```json
{
  "name": "GetHome",
  "displayName": "Get Home Page",
  "method": "GET",
  "urlTemplate": "/",
  "description": "Redirect to default TXT TV page (100)",
  "responses": [
    {
      "statusCode": 302,
      "description": "Redirect to page 100",
      "headers": [
        {
          "name": "Location",
          "description": "Redirect URL",
          "type": "string",
          "values": ["/page/100"]
        }
      ]
    }
  ]
}
```

### Operation: GetBackendTest

```json
{
  "name": "GetBackendTest",
  "displayName": "Backend Connectivity Test",
  "method": "GET",
  "urlTemplate": "/backend-test",
  "description": "Call the F# Azure Function backend to verify connectivity through WAF and APIM",
  "responses": [
    {
      "statusCode": 200,
      "description": "Backend responded successfully",
      "representations": [
        {
          "contentType": "text/plain"
        }
      ]
    },
    {
      "statusCode": 503,
      "description": "Backend unavailable",
      "representations": [
        {
          "contentType": "application/json"
        }
      ]
    }
  ]
}
```

## Error Handling

### Global Error Policy

```xml
<on-error>
    <set-variable name="errorMessage" value="@(context.LastError.Message)" />
    <set-variable name="errorReason" value="@(context.LastError.Reason)" />
    
    <choose>
        <when condition="@(context.Response.StatusCode == 500)">
            <return-response>
                <set-status code="500" reason="Internal Server Error" />
                <set-header name="Content-Type" exists-action="override">
                    <value>application/json</value>
                </set-header>
                <set-body>@{
                    return new JObject(
                        new JProperty("error", "Internal server error"),
                        new JProperty("message", "An unexpected error occurred"),
                        new JProperty("correlationId", context.Variables["correlationId"])
                    ).ToString();
                }</set-body>
            </return-response>
        </when>
    </choose>
    
    <trace source="error" severity="error">
        <message>@($"Error: {context.Variables["errorReason"]} - {context.Variables["errorMessage"]}")</message>
        <metadata name="correlationId" value="@((string)context.Variables["correlationId"])" />
    </trace>
</on-error>
```

## Security Headers

All responses include these security headers (set in global policy):

```xml
<set-header name="X-Content-Type-Options" exists-action="override">
    <value>nosniff</value>
</set-header>
<set-header name="X-Frame-Options" exists-action="override">
    <value>DENY</value>
</set-header>
<set-header name="X-XSS-Protection" exists-action="override">
    <value>1; mode=block</value>
</set-header>
<set-header name="Strict-Transport-Security" exists-action="override">
    <value>max-age=31536000; includeSubDomains</value>
</set-header>
```

## CORS Configuration

Since HTMX makes requests from the same origin, CORS is not strictly required. However, for testing purposes:

```xml
<cors allow-credentials="false">
    <allowed-origins>
        <origin>*</origin>
    </allowed-origins>
    <allowed-methods>
        <method>GET</method>
    </allowed-methods>
    <allowed-headers>
        <header>*</header>
    </allowed-headers>
</cors>
```

## Logging and Tracing

Every request includes correlation ID for tracing:

```xml
<set-variable name="correlationId" value="@(Guid.NewGuid().ToString())" />
<set-header name="X-Correlation-ID" exists-action="override">
    <value>@((string)context.Variables["correlationId"])</value>
</set-header>

<trace source="apim-policy" severity="information">
    <message>@($"Request to {context.Request.Url.Path}")</message>
    <metadata name="correlationId" value="@((string)context.Variables["correlationId"])" />
    <metadata name="pageNumber" value="@((string)context.Variables.GetValueOrDefault("pageNumber", "N/A"))" />
</trace>
```

## Performance Expectations

| Operation | P50 | P95 | P99 |
|-----------|-----|-----|-----|
| GET /page/{pageNumber} | 50ms | 100ms | 200ms |
| GET / | 20ms | 50ms | 100ms |
| GET /backend-test | 100ms | 200ms | 500ms |

Note: These are target values assuming APIM policy caching and minimal backend latency.
